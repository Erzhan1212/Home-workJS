// //?! Task-1
// const student1={
//     name:"Jhon",
//     lang:"KG",
//     age:"24"
// };
//  const student2=student1;
//  console.log(student1);

// function deletePropery(
//     student1,student2
// ){
//    if(student1.length===student2.length) {delete student2.age}
// };
// deletePropery( student1,student2);
//  console.log(student2);
// //?!Task-2
// `Примитивные типы данных (числа, булевы и строки) хранятся и сравниваются по значению.
//  Можно безопасно менять значение переменной и не бояться, что изменится что-то ещё
//  Ссылочные типы данных (объекты, массивы) хранятся и сравниваются по ссылке.
//  При этом при сравнении будет учитываться именно факт того, что две переменные ссылаются на один и тот же объект.
//  Даже если два объекта содержат идентичные значения это ни на что не повлияет
// Изменения внутри объекта будут видны всем у кого есть ссылка на этот объект.
// Прямое изменение данных объекта называется мутирование. Лучше стараться
// избегать мутации объекта, т.к это может приводить к неочевидным ошибкам
// Чтобы безопасно менять ссылочный тип данных его необходимо предварительно скопировать.
// Таким образом будет создана другая ссылка и любые изменения не затронут старый объект`;
// `В целом, все вроде понятно — JavaScript выделяет память под все, что разработчик задает в коде,
//  а потом, когда все операции выполнены, память освобождается. Но где хранятся данные?

// Есть два варианта — в стеке (stack) памяти и в куче (heap). Что первое, что второе —
// название структур данных, которые используются движком для разных целей.

// Стек (stack) — это статическое выделение памяти
// Определение стека известно многим. Это структура данных,
// которая используется для хранения статических данных,
//  их размер всегда известен во время компиляции.
// Движок «понимает», что размер данных не меняется,
// поэтому выделяет фиксированный объем памяти для каждого из значений.
// Процесс выделения памяти до исполнения называется
// статическим выделением памяти (static memory allocation).
// Так как браузер выделяет память заранее для каждого т
// ипа данных есть ограничение на размер данных,которые можно туда положить.
//  Так как браузер выделяет память заранее для каждого типа данных есть
//   ограничение на размер данных, которые можно туда положить.

// Куча (heap) — динамическое выделение памяти.
// Что касается кучи, то она знакома многим не хуже, чем стек.
// Используется она для хранения объектов и функций.
// Но в отличие от стека движок не может «знать»,
// какой объем памяти необходим для того либо иного объекта,
//  поэтому память выделяется по мере необходимости.
//  И этот способ выделения памяти называется «динамическим» (dynamic memory allocation).`.

//?!Task-3
const array = [
  1,
  true,
  3,
  { name: "ZH", hobbies: ["swimming", "reading"] },
  5,
  "hello",
  "hi",
];
console.log(array);
let res = array[1];
console.log(res);
let res1 = array[4];
console.log(res1);
let res2 = array[3].hobbies;
console.log(res2);
// let res3 = array[3].hobbies.shift();
// console.log(res3);
// array.unshift( 8);
// console.log(array);
// array.push("end");
// console.log(array);
// array.shift(0);
// console.log(array);
// let res4 = array.indexOf("hello");
// console.log(res4);
// let res5 = array.slice(0, 3);
// console.log(res5);
//  array[3].hobbies=['swimming','reading','football'];
// console.log(array);
// array.splice(4,5,'hi');
// console.log(array);

// console.log(array.length);
// //?!Task-4
// const array1=[1,2,3,'sdf',4,{},3,true,2,[1,2,3],1];

// let sum = array1.reduce((prevVal, currVal, index)=> {
//     if (typeof prevVal =="number" && typeof currVal =="number"){
//      return currVal+prevVal;
//     } else {
//       return prevVal;
//    }
//    });
// console.log(sum);
// // //?! Task-5
// let string="hello, i am from kyrgyzstan";
// for(const iterator of "hello, i am from kyrgyzstan" ){
//     console.log(iterator.toUpperCase());
// };


